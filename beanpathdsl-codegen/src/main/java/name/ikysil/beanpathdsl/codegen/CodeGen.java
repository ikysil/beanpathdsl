/*
 * Copyright 2016 Illya Kysil <ikysil@ikysil.name>.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package name.ikysil.beanpathdsl.codegen;

import com.squareup.javapoet.AnnotationSpec;
import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.CodeBlock;
import com.squareup.javapoet.FieldSpec;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.ParameterizedTypeName;
import com.squareup.javapoet.TypeSpec;
import java.beans.IndexedPropertyDescriptor;
import java.beans.PropertyDescriptor;
import java.io.IOException;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Map;
import javax.annotation.Generated;
import javax.lang.model.element.Modifier;
import name.ikysil.beanpathdsl.codegen.configuration.IncludedClass;
import name.ikysil.beanpathdsl.core.BeanPath;
import org.apache.commons.lang3.StringUtils;

/**
 *
 * @author Illya Kysil <ikysil@ikysil.name>
 */
class CodeGen {

    public static final String SOURCE_CLASS_FIELD_NAME = "SOURCE_CLASS";

    private final Configuration configuration;

    public CodeGen(Configuration configuration) {
        this.configuration = configuration;
    }

    public void process() {
        Context context = new Context();
        context.scanAnnotatedElements();
        final Map<Class<?>, IncludedClass> transitiveClosure = context.buildTransitiveClosure();
        buildClassNames(transitiveClosure);
        for (Map.Entry<Class<?>, IncludedClass> entry : transitiveClosure.entrySet()) {
            Class<?> clazz = entry.getKey();
            generateBeanPathSource(context, transitiveClosure, clazz);
        }
    }

    private final Map<Class<?>, ClassName> classNames = new HashMap<>();

    private void buildClassNames(Map<Class<?>, IncludedClass> transitiveClosure) {
        for (Map.Entry<Class<?>, IncludedClass> entry : transitiveClosure.entrySet()) {
            Class<?> clazz = entry.getKey();
            String targetPackageName = getTargetPackageName(clazz);
            String targetClassName = getTargetClassName(clazz);
            classNames.put(clazz, ClassName.get(targetPackageName, targetClassName));
        }
    }

    private String getTargetPackageName(Class<?> clazz) {
        StringBuilder sb = new StringBuilder(clazz.getPackage().getName());
        if (!StringUtils.isBlank(configuration.getPackageNameSuffix())) {
            sb.append(".").append(configuration.getPackageNameSuffix());
        }
        return sb.toString();
    }

    private String getTargetClassName(Class<?> clazz) {
        StringBuilder sb = new StringBuilder();
        if (!StringUtils.isBlank(configuration.getClassNamePrefix())) {
            sb.append(configuration.getClassNamePrefix());
        }
        sb.append(ClassName.get(clazz).simpleName());
        if (!StringUtils.isBlank(configuration.getClassNameSuffix())) {
            sb.append(configuration.getClassNameSuffix());
        }
        String result = sb.toString();
        return result;
    }

    private String getInstanceAccessor(Class<?> clazz) {
        if (BeanPath.class.equals(clazz)) {
            return "getInstance()";
        }
        else {
            return "INSTANCE";
        }
    }

    private void generateBeanPathSource(Context context, Map<Class<?>, IncludedClass> transitiveClosure, Class<?> clazz) {
        ClassName targetClassName = classNames.get(clazz);

        AnnotationSpec generatedSpec = AnnotationSpec.builder(Generated.class)
                .addMember("value", "$S", String.format("Generated by beanpath-codegen for %s", ClassName.get(clazz)))
                .build();

        PropertyDescriptor[] pds = context.getPropertyDescriptors(clazz);
        Arrays.sort(pds, new Comparator<PropertyDescriptor>() {

            @Override
            public int compare(PropertyDescriptor o1, PropertyDescriptor o2) {
                return o1.getName().compareTo(o2.getName());
            }

        });

        Collection<FieldSpec> fieldSpecs = new ArrayList<>();
        Collection<MethodSpec> methodSpecs = new ArrayList<>();

        FieldSpec fieldSpec = FieldSpec.builder(targetClassName, getInstanceAccessor(clazz))
                .addModifiers(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL)
                .initializer("new $T()", targetClassName)
                .build();
        fieldSpecs.add(fieldSpec);

        final ParameterizedTypeName fieldTypeName = ParameterizedTypeName.get(ClassName.get(Class.class), ClassName.get(clazz));
        fieldSpec = FieldSpec.builder(fieldTypeName, SOURCE_CLASS_FIELD_NAME)
                .addModifiers(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL)
                .initializer("$T.class", clazz)
                .build();
        fieldSpecs.add(fieldSpec);

        for (PropertyDescriptor pd : pds) {
            String name = pd.getName();
            if (!Character.isJavaIdentifierStart(name.charAt(0))) {
                name = "_" + name;
            }
            if ("class".equals(name)) {
                name = "_" + name;
            }
            Class<?> pdClass = pd.getPropertyType();
            if ((pdClass == null) && (pd instanceof IndexedPropertyDescriptor)) {
                pdClass = ((IndexedPropertyDescriptor) pd).getIndexedPropertyType();
            }
            ClassName bpAccessorClassName = classNames.get(pdClass);
            if (bpAccessorClassName == null) {
                pdClass = BeanPath.class;
                bpAccessorClassName = ClassName.get(pdClass);
            }
            MethodSpec pdMethodSpec = MethodSpec.methodBuilder(name)
                    .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
                    .returns(bpAccessorClassName)
                    .addCode(CodeBlock.builder()
                            .addStatement("extendCurrentPath($S)", pd.getName())
                            .addStatement("return $T.$N", bpAccessorClassName, getInstanceAccessor(pdClass))
                            .build()
                    )
                    .build();
            methodSpecs.add(pdMethodSpec);

            pdMethodSpec = MethodSpec.methodBuilder(name)
                    .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
                    .addParameter(ClassName.get(String.class), "propertyName", Modifier.FINAL)
                    .returns(bpAccessorClassName)
                    .addCode(CodeBlock.builder()
                            .addStatement("extendCurrentPath($N)", "propertyName")
                            .addStatement("return $T.$N", bpAccessorClassName, getInstanceAccessor(pdClass))
                            .build()
                    )
                    .build();
            methodSpecs.add(pdMethodSpec);
        }

        MethodSpec constructor = MethodSpec.constructorBuilder()
                .addModifiers(Modifier.PRIVATE)
                .build();
        methodSpecs.add(constructor);

        TypeSpec typeSpec = TypeSpec.classBuilder(targetClassName)
                .superclass(ClassName.get(BeanPath.class))
                .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
                .addAnnotation(generatedSpec)
                .addFields(fieldSpecs)
                .addMethods(methodSpecs)
                .build();

        JavaFile javaFile = JavaFile.builder(targetClassName.packageName(), typeSpec)
                .skipJavaLangImports(true)
                .indent("    ")
                .build();

        try {
            javaFile.writeTo(Paths.get(configuration.getOutputDirectory()));
        }
        catch (IOException ex) {
            throw new RuntimeException(ex);
        }
    }

}
